# 第三十六题——有效的数独

### 题目

> 判断一个 9x9 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。
>
> 1. 数字 `1-9` 在每一行只能出现一次。
>
> 2. 数字 `1-9` 在每一列只能出现一次。
>
> 3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。
>
>    ![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)
>
> 上图是一个部分填充的有效的数独。
>
> 数独部分空格内已填入了数字，空白格用 `'.'` 表示。
>
> **说明:**
>
> - 一个有效的数独（部分已被填充）不一定是可解的。
> - 只需要根据以上规则，验证已经填入的数字是否有效即可。
> - 给定数独序列只包含数字 `1-9` 和字符 `'.'` 。
> - 给定数独永远是 `9x9` 形式的。

### 举例

```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true

输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

### 思路

* 思路：分成两个部分，第一部分检查横的和竖的有没有重复，第二部分检查小块的有没有重复。考虑用一个长度为9的数组来存1-9数字的个数，如果超过1就说明有重复。横竖部分用两重来循环，一个表示横的一个表示竖的，然后挨个检查如果有数字就更新数组并检查是否重复，有重复就返回false。小块部分需要用三重循环，最外一层循环长度为9可以和横竖部分结合，内两层长度为3，同样的检查并更新数组。最后返回true。
* solution：思路其实差不多，但不同在把用数组检查重复的部分单独写成函数，每次先把9个字符写进一个vector，然后调用函数来检查重复。
* solution 2：这个思路很妙，把检查用的数组做成三个9*9的二维数组，就是一个数组检查9个横的，一个检查9个竖的，一个检查9个小块。双重循环遍历数独，每次遇到是数字的位，就更新第一个检查数组中对应行的这个数字的位的值，同时检查是否>1，另外两个同理。

### 复杂度

- 
- 


### 源码

* 思路

  ```c++
  class Solution {
  public:
      bool isValidSudoku(vector<vector<char>>& board) {
  		for (int i = 0; i < 9; i++) {
  			int count[9] = { 0 };
  			int count0[9] = { 0 };
  			for (int j = 0; j < 9; j++) {
  				char t = board[i][j];
  				if (t != '.') {
  					if (count[t - '0' - 1] == 1)
  						return false;
  					count[t - '0' - 1]++;
  				}
  				t = board[j][i];
  				if (t != '.') {
  					if (count0[t - '0' - 1] == 1)
  						return false;
  					count0[t - '0' - 1]++;
  				}
  			}
  			int count00[9] = { 0 };
  			for (int k = 0; k < 3; k++) {
  				for (int j = 0; j < 3; j++) {
  					char t = board[k + 3 * (i / 3)][j + 3 * (i % 3)];
  					//cout << k + 3 * (i / 3) << " " << j + 3 * (i % 3) << "    ";
  					if (t != '.') {
  						if (count00[t - '0' - 1] == 1)
  							return false;
  						count00[t - '0' - 1]++;
  					}
  				}
  			}
  		}
          return true;
      }
  };
  ```

* solution 2

  ```c++
  class Solution {
  public:
      bool isValidSudoku(vector<vector<char>>& board) {
  		int count[9][9] = { 0 };
  		int count0[9][9] = { 0 };
  		int count00[9][9] = { 0 };
  		for (int i = 0; i < 9; i++) {
  			for (int j = 0; j < 9; j++) {
  				char t = board[i][j] - '0' - 1;
  				if (board[i][j] != '.') {
  					if (count[i][t] == 1)
  						return false;
  					count[i][t]++;
  					if (count0[t][j] == 1)
  						return false;
  					count0[t][j]++;
  					if (count00[i / 3 * 3 + j / 3][t] == 1)
  						return false;
  					count00[i / 3 * 3 + j / 3][t]++;
  				}
  			}
  		}
          return true;
      }
  };
  ```


