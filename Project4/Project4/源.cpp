#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

//不确定到底对不对
//class Solution{
//public:
//	int mindis(int n, int c, vector<int> pos) {
//		sort(pos.begin(), pos.end());
//		if (c == 2) {
//			return pos[1] - pos[0];
//		}
//		int maxdis = (pos[c - 1] - pos[0]) / (n - 1);
//		int mindis = floor(c / (n - 1));
//		for (int i = maxdis; i >= mindis; i--) {
//			int last = 0;
//			int count = 1;
//			for (int j = 1; j < c; j++) {
//				if (pos[j] - pos[last] >= i) {
//					last = j;
//					count++;
//				}
//			}
//			if (count >= n) {
//				cout << i;
//				return i;
//			}
//		}
//		cout << "wrong";
//		return 1;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<int> p = { 1,2,4,8,9 };
//	s.mindis(3, 5, p);
//	system("pause");
//	return 0;
//}



//还是有问题，不知道错哪里
//vector<int> calcount(vector<int> d, vector<int> c, int p,int n) {	
//	int s = p >= d[p] ? p - d[p] : 0;
//	int e = (p + d[p]) >= n ? n-1 : p + d[p];
//	//cout << p << " "<<s<<" "<<e;
//	for (int i = s; i <= e;i++) {
//		int t = c[p] + 1;
//		if (c[i] > t) {
//			c[i] = t;
//			//cout << " " << t << endl;
//			c = calcount(d, c, i, n);
//		}
//	}
//	return c;
//}
//
//int main() {
//	//freopen("1.in","r",stdin);
//	int n = 7;
//	int p = 4;
//	vector<int> dis = { 10,0,2,1,1,0,1 };
//	//cin >> n;
//	//cin >> p;
//	//for (int i = 0; i < n; i++) {
//	//	int x; 
//	//	scanf_s("%d", &x);
//	//	dis.push_back(x);
//	//}
//	vector<int> count(n, 10001);
//	count[p - 1] = 0;
//	count = calcount(dis, count, p - 1,n);
//	
//	/*for (int i = 0; i < n; i++) {
//		cout << count[i] << " ";
//	}*/
//	if (count[n - 1] == 10001)
//		cout << -1;
//	else cout << count[n - 1];
//	system("pause");
//	return 0;
//}



//int main() {
//	//freopen("1.in","r",stdin);
//	int n = 0;
//	cin >> n;
//	if (n < 2)
//		return 0;
//	cout << 2;
//	for (int i = 3; i < n; i++) {
//		int j = 2;
//		int t = sqrt(i)+1;
//		//cout << t << endl;
//		for (j ; j < t; j++) {
//			if (i%j == 0) {
//				break;
//			}
//		}
//		if (j == t) {
//			cout << " " << i;
//		}
//	}
//	system("pause");
//	return 0;
//}



/**************************************周赛0623***************************************/
//#include<vector>
//#include<stack>
//#include<map>
//#include<string>
//#include<algorithm>
//class Solution {
//public:
//	vector<string> braceExpansionII(string expression) {
//		stack<char> sign;
//		stack<vector<string>> res;
//		int len = expression.length();
//		vector<string> strs;
//		int i = 0;
//		
//		while (i < len ) {
//			cout << i << " ";
//			if (expression[i] == '{') {
//				if (i > 0 && expression[i - 1] != ','&& expression[i - 1] != '{') {
//					//if (sign.empty()==true|| sign.top() != '*') {
//						sign.push('*');
//					//}
//				}
//				sign.push('{');
//				i++;
//			}
//			else if (expression[i] == '}') {
//				char s = sign.top();
//				while (s != '{') {					
//					cout << s;
//					vector<string> b = res.top();
//					res.pop();
//					vector<string> a = res.top();
//					res.pop();
//					if (s == '+') {
//						res.push(plusvector(a, b));
//					}
//					else if (s=='*') {
//						res.push(multvector(a, b));
//					}
//					sign.pop();
//					s = sign.top();
//					//cout << s;
//				}
//				sign.pop();
//				i++;
//			}
//			else if (expression[i] == ',') {
//				if (sign.empty() != true && sign.top() == '*') {
//					vector<string> b = res.top();
//					res.pop();
//					vector<string> a = res.top();
//					res.pop();
//					res.push(multvector(a, b));
//					sign.pop();
//				}
//				else {
//					sign.push('+');
//					i++;
//				}			
//			}
//			else {
//				if (i > 0 && expression[i - 1] == '}') {
//					cout << "}a" << " ";
//					sign.push('*');
//				}
//				string str = "";
//				while (expression[i] < 123 && expression[i] > 96) {
//					str += expression[i];
//					i++;
//				}
//				//cout << " " << str << " ";
//				res.push(vector<string>(1, str));
//			}
//			cout << endl;
//		}
//
//		while (sign.empty() != true) {
//			char s = sign.top();
//			cout << s << " ";
//			vector<string> b = res.top();
//			res.pop();
//			vector<string> a = res.top();
//			res.pop();
//			if (s == '+') {
//				res.push(plusvector(a, b));
//			}
//			else if (s == '*') {
//				res.push(multvector(a, b));
//			}
//			sign.pop();
//		}
//
//		vector<string> r = res.top();
//		sort(r.begin(), r.end());
//
//		for (int k = 0; k < r.size()-1; k++) {
//			if ( r[k] == r[k + 1]) {
//				r[k] = "";
//			}
//		}
//		vector<string> rr;
//		for (int j = 0; j < r.size(); j++) {
//			if (r[j] != "") {
//				rr.push_back(r[j]);
//			}
//		}
//		for (int j = 0; j < rr.size(); j++) {
//			cout << rr[j]<<" ";
//		}
//		return rr;
//	}
//
//	vector<string> plusvector(vector<string> a, vector<string> b) {
//		int l2 = b.size();
//		for (int i = 0; i < l2; i++) {
//			a.push_back(b[i]);
//		}
//
//		//cout << "plus";
//		//for (int i = 0; i < a.size(); i++) {
//		//	cout << a[i] << " ";
//		//}
//		//cout << "plus";
//		return a;
//	}
//
//	vector<string> multvector(vector<string> a,vector<string> b) {
//		int l1 = a.size();
//		int l2 = b.size();
//		for (int j = 1; j < l2; j++) {
//			for (int i = 0; i < l1; i++) {
//				a.push_back(a[i] + b[j]);
//			}
//		}
//		for (int i = 0; i < l1; i++) {
//			a[i] = a[i] + b[0];
//		}
//
//		//cout << "mult";
//		//for (int i = 0; i < a.size(); i++) {
//		//	cout << a[i] << " ";
//		//}
//		//cout << "mult";
//		return a;
//	}
//};
//
//int main() {
//	Solution s;
//	s.braceExpansionII("{{a,z},a{b,c},{ab,z}}");
//	system("pause");
//	return 0;
//}



// This is the MountainArray's API interface.
// You should not implement it, or speculate about its implementation
//class MountainArray {
//  public:
//    int get(int index);
//    int length();
//};
//
//#include<vector>
//class Solution {
//public:
//	int findInMountainArray(int target, MountainArray &mountainArr) {
//		int len = mountainArr.length();
//		int peek = findPeek(target, mountainArr, 0, len - 1);
//		int res1 = findInSlop(target, mountainArr, 0, peek, 1);
//		int res2 = findInSlop(target, mountainArr, peek, len - 1, 2);
//
//		if (res1 == -1 && res2 == -1)
//			return -1;
//		else if (res1 == -1)
//			return res2;
//		else if (res2 == -1)
//			return res1;
//		else return res1 < res2 ? res1 : res2;
//	}
//	int findPeek(int target, MountainArray &mountainArr,int start,int end) {
//		int res = start;
//		int mid = (start + end) / 2;
//		while (start <= end) {
//			mid = (start + end) / 2;
//			if (mountainArr.get(mid) < mountainArr.get(mid + 1)) {
//				start = mid + 1;
//			}
//			else {
//				end = mid - 1;
//			}
//		}
//		res = start;
//		cout << res;
//		return res;
//	}
//	int findInSlop(int target, MountainArray &mountainArr, int start, int end, int ind) {
//		int res = start;
//		int mid = (start + end) / 2;
//		while (start <= end) {
//			mid = (start + end) / 2;
//			int m = mountainArr.get(mid);
//			if (m == target)
//				return m;
//			else if (m < target) {
//				if (ind == 1)
//					start = mid + 1;
//				else end = mid - 1;
//			}
//			else {
//				if(ind==1)
//					end = mid - 1;
//				else start = mid + 1;
//			}
//		}
//		return -1;
//	}
//};



//#include<vector>
//class Solution {
//public:
//	bool carPooling(vector<vector<int>>& trips, int capacity) {
//		vector<int> count(1000, 0);
//		int len = trips.size();
//		if (len == 0)
//			return true;
//		for (int i = 0; i < len; i++) {
//			for (int j = trips[i][1]; j < trips[i][2]; j++) {
//				count[j] += trips[i][0];
//				if (count[j] > capacity) {
//					cout << j << "false";
//					return false;
//				}
//			}
//		}
//
//		return true;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<vector<int>> t = {
//		{ 3,2,7},{3,7,9},{8,3,9 }
//	};
//	s.carPooling(t,11);
//	system("pause");
//	return 0;
//}



//#include<vector>
//class Solution {
//public:
//	vector<double> sampleStats(vector<int>& count) {
//		double min = 0;
//		double max = 0;
//		long double sum = 0;
//		long int num = 0;
//		double ave = 0;
//		long double midnum = 0;
//		double mid = -1;
//		double mostnum = 0;
//		double most = 0;
//		bool flag = false;
//
//		for (int i = 0; i < 256; i++) {
//			if (count[i] != 0) {
//				num += count[i];
//				sum += i * count[i];
//				if (count[i] > mostnum) {
//					mostnum = count[i];
//					most = i;
//				}
//				//while (midnum < num / 2) {
//				//	mid++;
//				//	midnum += count[mid];
//				//}
//				max = i;
//				if (!flag) {
//					min = i;
//					flag = true;
//				}
//			}
//		}
//
//		while (midnum < num / 2) {
//			mid++;
//			midnum += count[mid];
//		}
//		if (num % 2 == 0) {
//			double tmp = mid;
//			while (midnum < (num / 2 + 1)) {
//				tmp++;
//				midnum += count[tmp];
//			}
//			mid += tmp;
//			mid /= 2;
//		}
//
//		ave = sum / num;
//		if(mid==-1)
//			mid=0;
//		vector<double> res = { min ,max ,ave ,mid ,most };
//		for (int i = 0; i < 5; i++)
//			cout << res[i] << " ";
//		return res;
//	}
//};

//int main() {
//	Solution s;
//	vector<int> c = { 2725123,2529890,2612115,3807943,3002363,3107290,2767526,981092,896521,2576757,2808163,3315813,2004022,2516900,607052,1203189,2907162,1849193,1486120,743035,3621726,3366475,639843,3836904,462733,2614577,1881392,85099,709390,3534613,360309,404975,715871,2258745,1682843,3725079,564127,1893839,2793387,2236577,522108,1183512,859756,3431566,907265,1272267,2261055,2234764,1901434,3023329,863353,2140290,2221702,623198,955635,304443,282157,3133971,1985993,1113476,2092502,2896781,1245030,2681380,2286852,3423914,3549428,2720176,2832468,3608887,174642,1437770,1545228,650920,2357584,3037465,3674038,2450617,578392,622803,3206006,3685232,2687252,1001246,3865843,2755767,184888,2543886,2567950,1755006,249516,3241670,1422728,809805,955992,415481,26094,2757283,995334,3713918,2772540,2719728,1204666,1590541,2962447,779517,1322374,1675147,3146304,2412486,902468,259007,3161334,1735554,2623893,1863961,520352,167827,3654335,3492218,1449347,1460253,983079,1135,208617,969433,2669769,284741,1002734,3694338,2567646,3042965,3186843,906766,2755956,2075889,1241484,3790012,2037406,2776032,1123633,2537866,3028339,3375304,1621954,2299012,1518828,1380554,2083623,3521053,1291275,180303,1344232,2122185,2519290,832389,1711223,2828198,2747583,789884,2116590,2294299,1038729,1996529,600580,184130,3044375,261274,3041086,3473202,2318793,2967147,2506188,127448,290011,3868450,1659949,3662189,1720152,25266,1126602,1015878,2635566,619797,2898869,3470795,2226675,2348104,2914940,1907109,604482,2574752,1841777,880254,616721,3786049,2278898,3797514,1328854,1881493,1802018,3034791,3615171,400080,2277949,221689,1021253,544372,3101480,1155691,3730276,1827138,3621214,2348383,2305429,313820,36481,2581470,2794393,902504,2589859,740480,2387513,2716342,1914543,3219912,1865333,2388350,3525289,3758988,961406,1539328,448809,1326527,1339048,2924378,2715811,376047,3642811,2973602,389167,1026011,3633833,2848596,3353421,1426817,219995,1503946,2311246,2618861,1497325,3758762,2115273,3238053,2419849,2545790 };
//	s.sampleStats(c);
//	system("pause");
//	return 0;
//}



/**************************************周赛0616***************************************/
//#include<vector>
//#include<queue>
//#include<map>
//#include<algorithm>
//class Solution {
//public:
//	int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
//		int len = grid.size();
//		if (grid[0][0] == 1 || grid[len - 1][len - 1] == 1)
//			return -1;
//		if (len == 1)
//			return 1;
//
//		vector<vector<int>> count(len, vector<int>(len, 10001));
//		count[0][0] = 1;
//		BFSpathcount(grid, count, len);
//		//DFSpathcount(grid, count, 0, 0, len);
//		for (int i = 0; i < len; i++) {
//			for (int j = 0; j < len; j++) {
//				cout << count[i][j] << " ";
//			}
//			cout << endl;
//		}
//		if (count[len - 1][len - 1] == 10001)
//			return -1;
//		else return count[len - 1][len - 1];
//	}
//
//	void BFSpathcount(vector<vector<int>> grid, vector<vector<int>>& count, int len) {
//		map<pair<int,int>,int> que;
//		que.insert(pair<pair<int,int>,int>(pair<int,int>(0, 0),0));
//		while (!que.empty()) {
//			pair<int, int> t = que.begin()->first;
//			int i = t.first;
//			int j = t.second;
//			que.erase(que.begin());
//			int tmp = count[i][j] + 1;
//			if (i > 0) {
//				if (grid[i - 1][j] == 0 && count[i - 1][j] > tmp) {
//					count[i - 1][j] = tmp;
//					que.insert(pair<pair<int, int>, int>(pair<int, int>(i - 1, j), 0));
//				}
//				if (j > 0) {
//					if (grid[i - 1][j - 1] == 0 && count[i - 1][j - 1] > tmp) {
//						count[i - 1][j - 1] = tmp;
//						que.insert(pair<pair<int, int>, int>(pair<int, int>(i - 1, j - 1), 0));
//					}
//				}
//				if (j < len - 1) {
//					if (grid[i - 1][j + 1] == 0 && count[i - 1][j + 1] > tmp) {
//						count[i - 1][j + 1] = tmp;
//						que.insert(pair<pair<int, int>, int>(pair<int, int>(i - 1, j + 1), 0));
//					}
//				}
//			}
//			if (i < len - 1) {
//				if (grid[i + 1][j] == 0 && count[i + 1][j] > tmp) {
//					count[i + 1][j] = tmp;
//					que.insert(pair<pair<int, int>, int>(pair<int, int>(i + 1, j), 0));
//				}
//				if (j > 0) {
//					if (grid[i + 1][j - 1] == 0 && count[i + 1][j - 1] > tmp) {
//						count[i + 1][j - 1] = tmp;
//						que.insert(pair<pair<int, int>, int>(pair<int, int>(i + 1, j-1), 0));
//					}
//				}
//				if (j < len - 1) {
//					if (grid[i + 1][j + 1] == 0 && count[i + 1][j + 1] > tmp) {
//						count[i + 1][j + 1] = tmp;
//						que.insert(pair<pair<int, int>, int>(pair<int, int>(i + 1, j+1), 0));
//					}
//				}
//			}
//			if (j > 0) {
//				if (grid[i][j - 1] == 0 && count[i][j - 1] > tmp) {
//					count[i][j - 1] = tmp;
//					que.insert(pair<pair<int, int>, int>(pair<int, int>(i, j-1), 0));
//				}
//			}
//			if (j < len - 1) {
//				if (grid[i][j + 1] == 0 && count[i][j + 1] > tmp) {
//					count[i][j + 1] = tmp;
//					que.insert(pair<pair<int, int>, int>(pair<int, int>(i, j+1), 0));
//				}
//			}
//		}		
//		return;
//	}
//
//	//void DFSpathcount(vector<vector<int>> grid, vector<vector<int>>& count, int i, int j, int len) {
//	//	//cout << i<<" "<<j << endl;
//	//	int tmp = count[i][j] + 1;
//	//	if (i > 0) {
//	//		if (grid[i - 1][j] == 0 && count[i - 1][j] > tmp) {
//	//			count[i - 1][j] = tmp;
//	//			DFSpathcount(grid, count, i-1, j, len);
//	//		}
//	//		if (j > 0) {
//	//			if (grid[i - 1][j-1] == 0 && count[i - 1][j - 1] > tmp) {
//	//				count[i - 1][j - 1] = tmp;
//	//				DFSpathcount(grid, count, i-1, j-1, len);
//	//			}
//	//		}
//	//		if (j < len - 1) {
//	//			if (grid[i - 1][j+1] == 0 && count[i - 1][j + 1] > tmp) {
//	//				count[i - 1][j + 1] = tmp;
//	//				DFSpathcount(grid, count, i-1, j+1, len);
//	//			}
//	//		}
//	//	}
//	//	if (i < len - 1) {
//	//		if (grid[i + 1][j] == 0 && count[i + 1][j] > tmp) {
//	//			count[i + 1][j] = tmp;
//	//			DFSpathcount(grid, count, i+1, j, len);
//	//		}
//	//		if (j > 0) {
//	//			if (grid[i + 1][j - 1] == 0 && count[i + 1][j - 1] > tmp) {
//	//				count[i + 1][j - 1] = tmp;
//	//				DFSpathcount(grid, count, i+1, j-1, len);
//	//			}
//	//		}
//	//		if (j < len - 1) {
//	//			if (grid[i + 1][j + 1] == 0 && count[i + 1][j + 1] > tmp) {
//	//				count[i + 1][j + 1] = tmp;
//	//				DFSpathcount(grid, count, i+1, j+1, len);
//	//			}
//	//		}
//	//	}
//	//	if (j > 0) {
//	//		if (grid[i][j - 1] == 0 && count[i][j - 1] > tmp) {
//	//			count[i][j - 1] = tmp;
//	//			DFSpathcount(grid, count, i, j - 1, len);
//	//		}
//	//	}
//	//	if (j < len - 1) {
//	//		if (grid[i][j + 1] == 0 && count[i][j + 1] > tmp) {
//	//			count[i][j + 1] = tmp;
//	//			DFSpathcount(grid, count, i, j + 1, len);
//	//		}
//	//	}
//	//	return;
//	//}
//};
//
//int main() {
//	Solution s;
//	vector<vector<int>> g = {
//		{ 0,1,0,1,1,0,1,0,1,0,1,1,1,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,0,0,1,1,1,0,1,1,0,0,1,1,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1},{1,0,0,0,1,0,0,1,0,0,1,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,0,0,0,1,1},{0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,0,0,1,1},{0,0,1,1,0,1,1,1,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0,1,0,0},{0,0,1,1,1,0,1,1,1,1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,1,1,0,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,0,0,1,0,1,1,0,1,0},{1,0,1,1,1,1,0,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,1},{0,0,0,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,0,0,0},{1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1},{1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,1,1,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,1,0},{0,1,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,1,0,1,1,1,0,1,0,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,0,1,1,1,0,1,0,1,0,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1},{1,0,0,1,0,0,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1},{0,1,1,1,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,0,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0},{0,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,1,0,0,1,0,0,0,1,1,1,1,0,1,0,0,1,1,1,0},{1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,1,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1},{0,0,1,1,1,0,0,0,1,0,0,1,1,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,0,0},{0,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,0,0,0},{0,1,1,0,1,0,0,0,1,0,1,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,0,1,0,1,1,1,0,1,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,0,1,0,0,0,1,0},{0,0,1,0,0,1,1,1,1,0,0,0,1,1,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,0,1,0},{1,0,0,1,1,0,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1},{0,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,0,0,1,0,1,0,0,0,0},{1,1,1,1,0,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,1,0,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0},{0,0,0,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,1,1,0,1,1,1,1,0,0,0,1,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,1,1,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,0},{1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1,1,1},{1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,1,0,0,1},{1,1,0,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,0,1,1},{0,1,0,0,1,0,1,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,1,0,0,0,1,1},{0,1,0,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,0,0,0,1,1,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,0,1},{1,1,0,0,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1,0,1,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,1},{1,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0},{1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,0},{1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,0,1},{1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,0,1,0,0},{0,0,1,1,1,0,1,1,0,0,0,1,0,1,1,0,0,1,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,1,1,1,0,1,0,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1},{0,1,0,1,0,0,0,0,0,0,1,0,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,0},{0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,1,0,0,1,1,1,0,1,0},{1,0,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,0,1,0,0,1,1,1,0,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1},{1,0,0,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,1,0,0,0},{0,1,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,0,1},{0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,1},{1,1,1,0,1,0,1,0,1,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,1,1,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,1,1,1},{0,0,0,1,0,1,0,1,0,1,0,0,1,1,0,0,1,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0,1,0,0,1,1,0,1,0,0,0,0,0,1},{1,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,0,1,0,0,1,1,0,0,0,0,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,1,0,1,1,1,1,0,0,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,1,1},{1,1,0,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,1,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1},{0,1,0,0,1,0,0,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,0,0,0,1,0,1,1,0,1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,1,1,0},{1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0},{0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,1,1,0,0},{1,1,1,0,1,0,1,1,1,0,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,0,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0},{0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,1,1,1,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0},{1,1,1,0,1,0,0,1,0,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,0,1,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,1,0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,1,0,0,1,0},{1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,1,1,0,1,0,0,1,0,1,0,1,1,1,1,1},{0,0,0,1,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,1,0,0,1,1,0},{1,0,1,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1},{1,1,0,1,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,0,0,1,1,1,1},{1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,0,1},{1,1,0,0,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,1,0,1,0,0,0,1,0,1,1,1,0,1,1,1,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1,0,1,0,1,0,1},{0,0,1,1,1,1,0,1,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,1,0,0,0,1,1,1},{1,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},{0,1,1,1,0,0,0,1,0,0,0,0,1,1,1,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,0,0,0,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,1,1,1,0,0,0,0},{0,1,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,1,1},{0,0,1,1,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,0,1,0,0,0,0,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,0,1},{0,1,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,1,0},{0,0,0,1,1,1,1,0,1,1,0,0,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,1},{0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,0,0,0,1,1,1,1,1,1,0,0,0,1,1,0,0},{0,1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1},{0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,0,0},{0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,0,0,0,0,0,1,0,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,0,1,1,0,0,1,0,1,1},{1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,1,1,1,1,0,1,0,0},{0,0,1,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,0,0,0},{1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,1,1,1,0,1,1,1,0,0,1,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,0,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,1,1,0,1},{1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0},{1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,1,0,0,1,1,1,0,0,1,1,1,1,1,0,1,0,0,0,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1},{0,1,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0},{0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,1,1,0,0,0,1,0},{1,0,1,1,1,0,0,1,1,1,1,1,0,0,1,1,0,1,1,1,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,1,0,1,0,0,1,0,1,1,0,0,0,0,0},{1,0,1,0,1,0,0,0,0,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1},{0,0,1,1,1,1,0,0,0,0,0,0,1,0,1,1,1,1,0,0,1,1,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,0,1,1,0},{0,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0},{0,1,0,0,0,0,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,1,0},{0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,1,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,1,1,1,1,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,1},{1,1,0,0,0,0,1,1,0,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1},{0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,1,0,1,1,1},{1,1,1,1,0,1,1,0,0,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0},{1,0,1,0,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,1,0,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0},{0,0,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,0,1,1,1,1,0,0,0,0,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,1,1,1,0,1,1,0,0,0,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1},{0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,0,0,0,0,1,1,1,1,0,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,0,0,1,0,1,1,0,1,0,0,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1},{1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,1,0,0,1,0,0,1,1,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0},{1,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,0,0,0,0,1,0,1,0,1,1,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,1,0,0},{1,1,0,0,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1},{0,0,1,1,1,1,0,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1},{1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,0,0,0,1,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1},{0,1,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,0,0,1,1,1,0,1,1,0,1,1,1,1,0,1,1},{1,1,0,1,0,0,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,1,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0},{0,0,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,1,0,0,0,0,1,0,0,1,0,1},{0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,0,1,1},{0,0,0,1,0,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0,1,1,0,1,0,0,0},{0,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1},{0,1,1,0,1,0,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0},{0,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,0,1,1,1,0,0,0,0,1,1,1,1,0,1,0 }
//	};
//	s.shortestPathBinaryMatrix(g);
//	system("pause");
//	return 0;
//}



//#include<vector>
//#include<map>
//#include<algorithm>
//class Solution {
//public:
//	int largestValsFromLabels(vector<int>& values, vector<int>& labels, int num_wanted, int use_limit) {
//		int len = values.size();
//		int res = 0;
//		//第一种情况
//		if (num_wanted <= use_limit) {
//			if (num_wanted != len) {
//				sort(values.begin(), values.end());
//			}
//			for (int i = len-1; i >= len-num_wanted; i--) {
//				res += values[i];
//			}
//			cout << res;
//			return res;
//		}
//		
//		map<int, map<pair<int, int>, int>> label;
//		for (int i = 0; i < len; i++) {
//			map<int, map<pair<int, int>, int>>::iterator it = label.find(labels[i]);
//			if (it!=label.end()) {
//				it->second.insert(pair<pair<int, int>, int > (pair<int, int>(values[i], i), 0));
//			}
//			else {
//				label.insert(pair<int, map<pair<int, int>, int>>(labels[i], map<pair<int, int>, int> {pair<pair<int, int>, int>(pair<int, int>(values[i], i), 0)}));
//			}
//		}
//		//for (auto i = label.begin(); i !=label.end(); i++) {
//		//	cout << i->first << " " /*<< i->second*/<< endl;
//		//	for (auto j = i->second.begin(); j != i->second.end(); j++) {
//		//		cout << j->first.first << " " << j->first.second << endl;
//		//	}
//		//}
//		int labelcount = label.size();
//		if (num_wanted >= labelcount*use_limit) {
//			cout << "0" << endl;
//			for (auto i = label.begin(); i !=label.end(); i++) {
//				//cout << i->first << " " /*<< i->second*/<< endl;
//				int c = use_limit;
//				for (auto j = i->second.rbegin(); j != i->second.rend()&&c > 0; j++,c--) {
//					//cout << j->first.first << " " << j->first.second << endl;
//					res += j->first.first;
//					cout << c<<" ";
//				}
//			}
//		}
//		else {
//			cout << "1" << endl;
//			map<pair<int, int>, int> tmp;
//			for (auto i = label.begin(); i != label.end(); i++) {
//				//cout << i->first << " " /*<< i->second*/<< endl;
//				int c = use_limit;
//				for (auto j = i->second.rbegin(); j != i->second.rend() && c > 0; j++, c--) {
//					//cout << j->first.first << " " << j->first.second << endl;
//					tmp.insert(pair<pair<int,int>,int>(j->first,j->second));
//				}
//			}
//			int c = num_wanted;
//			for (auto i = tmp.rbegin(); i != tmp.rend()&& c>0 ; i++,c--) {
//				res += i->first.first;
//			}
//		}
//
//		cout << res;
//		return res;
//	}
//};
//
//int main() {
//	vector<int> values = { 2,6,1,2,6 };
//		vector<int>	labels = { 2,2,2,1,1 };
//		int	num_wanted = 1;
//		int	use_limit = 1;
//		Solution s;
//		s.largestValsFromLabels(values, labels, num_wanted, use_limit);
//		system("pause");
//		return 0;
//}



//#include<vector>
//class Solution {
//public:
//	void duplicateZeros(vector<int>& arr) {
//		int len = arr.size();
//		int count = 0;
//		for (int i = 0; i < len; i++) {
//			if (arr[i] == 0)
//				count++;
//		}
//		if (count == 0)
//			return;
//		//前一个指针的ind
//		int j = len - 1;
//		while(count > 0) {
//			if (arr[j] == 0) {
//				j --;
//				count -= 2;
//			}
//			else {
//				j--;
//				count--;
//			}
//		}
//		int i = len - 1;
//		//特殊情况：最后一个是0，且刚好不重写
//		if (count < 0) {
//			arr[len - 1] = 0;
//			i--;
//		}
//		cout << i << endl;
//		for (i; i >= 0; i--,j--) {
//			if (arr[j] == 0) {
//				arr[i] = arr[j];
//				i--;
//				arr[i] = arr[j];
//			}
//			else arr[i] = arr[j];
//		}
//		for (int k = 0; k < len; k++)
//			cout << arr[k] << " ";
//
//		return;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<int> a = { 1,2,3};
//	s.duplicateZeros(a);
//	system("pause");
//	return 0;
//}



/**************************************周赛0602***************************************/
//#include<vector>
//#include<queue>
////Definition for a binary tree node.
//struct TreeNode {
//    int val;
//    TreeNode *left;
//    TreeNode *right;
//	TreeNode(int x) : val(x), left(NULL), right(NULL) {}
//};
//
//class Solution {
//public:
//	TreeNode * sufficientSubset(TreeNode* root, int limit) {
//		vector<int> tree(10, 1000000);
//		queue<TreeNode> q;
//		q.push(*root);
//		tree[0] = root->val;
//		int ind = 1;
//		while (!q.empty()) {
//			TreeNode t = q.front();
//			q.pop();
//			//cout << ind << " ";
//			while (tree[ind-1] == 1000000){
//				ind++;
//			}
//			//cout << ind << "   ";
//			int len = tree.size();
//			if (len <= ind * 2) {
//				//把tree长度翻倍			
//				for (int k = 0; k < len; k++) {
//					tree.push_back(1000000);
//				}
//				tree.push_back(1000000);
//				len *= 2;
//			}
//			if (t.left) {
//				tree[ind * 2 - 1] = t.left->val;
//				q.push(*t.left);
//			}
//			else {
//				tree[ind*2-1]=1000000;
//			}
//			if (t.right) {
//				tree[ind * 2] = t.right->val;
//				q.push(*t.right);
//			}
//			else {
//				tree[ind * 2] = 1000000;
//			}
//			ind++;
//		}
//		cout << endl;
//		for (int k = 0; k < tree.size(); k++) {
//			cout << tree[k] << " ";
//		}
//		cout << ind;
//
//		vector<int> treeflag = tree;
//		//注意这里的i是从1开始算的而不是数组的下标
//		for (int i = ind / 2 ; i < ind; i++) {
//			int t = i;
//			int sum = 0;
//			while (t >= 1) {
//				sum += tree[t-1];
//				t /= 2;
//			}
//			cout << sum;
//			if (sum > limit) {
//				t = i / 2;
//				while (t >= 1) {
//					treeflag[t-1] = 1;
//					t /= 2;
//				}
//			}
//			else treeflag[i - 1] = 0;
//		}
//
//		for (int i = 1; i < ind; i++) {
//			cout << treeflag[i - 1] << " ";
//			if (treeflag[i - 1] == 0) {
//				tree[i - 1] = null;
//			}
//		}
//
//		return root;
//	}
//};
//
//int main() {
//	Solution s;
//
//	TreeNode t1(1);
//	TreeNode t2(2);
//	TreeNode t3(3);
//	TreeNode t4(4);
//	TreeNode t5(-99);
//	TreeNode t6(-99);
//	TreeNode t7(7);
//	TreeNode t8(8);
//	TreeNode t9(9);
//	TreeNode t10(-99);
//	TreeNode t11(-99);
//	TreeNode t12(12);
//	TreeNode t13(13);
//	TreeNode t14(-99);
//	TreeNode t15(15);
//	t1.left = &t2;
//	t1.right = &t3;
//	t2.left = &t4;
//	//t2.right = &t5;
//	t3.right = &t7;
//	t3.left = &t6;
//	t4.left = &t8;
//	t4.right = &t9;
//	t5.left = &t10;
//	t5.right = &t11;
//	t6.left = &t12;
//	t6.right = &t13;
//	t7.left = &t14;
//	t7.right = &t15;
//	s.sufficientSubset(&t1,1);
//	system("pause");
//	return 0;
//}



//#include<vector>;
//#include<string>
//class Solution {
//public:
//	vector<string> findOcurrences(string text, string first, string second) {
//		int len = text.size();
//		int lenf = first.size();
//		int lens = second.size();
//		vector<string> res;
//		if (len == 0)
//			return res;
//
//		vector<int> ind = findfirststring(text, first);
//		for (int i = 0; i < ind.size(); i++) {
//			string tmp = text.substr(ind[i] + lenf + 1, lens);
//			//cout << tmp << endl;
//			if (tmp == second) {
//				string t = "";
//				int j = ind[i] + lenf + lens + 2;
//				while (j < len && text[j] != ' ') {
//					t += text[j];
//					j++;
//				}
//				cout << t<<" ";
//				if(t!="")
//					res.push_back(t);
//			}
//		}
//
//		return res;
//	}
//
//	vector<int> findfirststring(string f,string s) {		
//		vector<int> res;
//		int lf = f.size();
//		int ls = s.size();
//		size_t ind = f.find_first_of(s[0]);
//		while (ind != string::npos&& ind < lf - ls) {
//			cout << ind;
//			int i = 0;
//			for (i ; i < ls; i++) {
//				if (f[ind+i] != s[i]) {
//					//cout <<i<<" "<< f[ind + i]<<" "<< s[i];
//					break;
//				}
//			}
//			cout << f[ind + i] << endl;
//			if (i == ls && f[ind + i]==' ') {
//				res.push_back(ind);				
//			}
//			ind = f.find_first_of(' ', ind + 1);
//			if (ind > lf - ls) break;
//			ind = f.find_first_of(s[0], ind + 1);
//		}
//
//		for (int i = 0; i < res.size(); i++) {
//			cout << res[i] << " ";
//		}
//		cout << endl;
//		return res;
//	}
//};
//
//int main() {
//	Solution s;
//	string t = "lxmji qktybghz spd qktybghz ka spd spd qktybghz qktybghz lxmji lxmji spd lxmji lxmji lxmji qktybghz spd ka qktybghz qktybghz ka lxmji ka qktybghz lxmji qktybghz qktybghz spd lxmji qktybghz";
//	string f = "ks";
//	string ss = "spd";
//	s.findOcurrences(t, f, ss);
//	system("pause");
//	return 0;
//}



/**************************************周赛0602***************************************/
//#include<vector>
//class Solution {
//public:
//	vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {
//		int len1 = arr1.size();
//		int len2 = arr2.size();
//		vector<int> res;
//		//让arr1是较长的
//		if (len1 < len2) {
//			int t = len1;
//			len1 = len2;
//			len2 = t;
//			res = arr2;
//			arr2 = arr1;
//			arr1 = res;
//		}
//
//		int i = len1-1;
//		int next = 0;
//		for (i; i >= 0; i--) {
//			if(i>= len1 - len2)
//				arr1[i] += arr2[i-(len1-len2)];
//			arr1[i] += next;
//			next = 0;
//			if (arr1[i] < 0) {
//				next = 1;
//				arr1[i] += 2;
//			}
//			if (arr1[i] > 1) {
//				next = -1;
//				arr1[i] -= 2;
//			}
//		}
//
//		while (next != 0) {
//			arr1.insert(arr1.begin(), next);
//			len1++;
//			next = 0;
//			if (arr1[0] < 0) {
//				next = 1;
//				arr1[0] += 2;
//			}
//			if (arr1[0] > 1) {
//				next = -1;
//				arr1[0] -= 2;
//			}
//		}
//		
//		while (len1>1 && arr1[0] == 0) {
//			arr1.erase(arr1.begin());
//			len1--;
//		}
//
//		for (int j = 0; j < len1; j++)
//			cout << arr1[j] << " ";
//		cout << endl;
//		return arr1;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<int> arr1 = {1,1 };
//	vector<int> arr2 = { 1};
//	s.addNegabinary(arr2, arr1);
//	system("pause");
//	return 0;
//}



//#include<vector>
//class Solution {
//public:
//	int maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {
//		int m = matrix.size();
//		int n = matrix[0].size();
//		vector<vector<int>> pattern = matrix;
//		for (int i = 0; i < m; i++) {
//			for (int j = 0; j < n; j++) {
//				pattern[i][j] = matrix[i][j] ^ matrix[i][0];
//				cout << pattern[i][j] << " ";
//			}
//			cout << endl;
//		}
//
//		vector<int> res(m, 0);
//		res[0] = 1;
//		//当前比较行
//		for (int k = 1; k < m; k++) {
//			int i = 0;
//			//和前面的每一行比较
//			for ( i = 0; i < k; i++) {
//				int j = 0;
//				for (j = 0; j < n; j++) {
//					if (pattern[k][j] != pattern[i][j])
//						break;
//				}
//				if (j == n) {
//					res[i]++;
//					break;
//				}
//			}
//			if (i == k)
//				res[k]++;
//		}
//		int max = res[0];
//		for (int i = 0; i < m; i++) {
//			cout << res[i];
//			if (res[i] > max)
//				max = res[i];
//		}
//		cout << max;
//		return max;
//	}
//};
//
//int main() {
//	vector<vector<int>> m = {
//		{ 1,0,0,0,1,1,1,0,1,1,1},{1,0,0,0,1,0,0,0,1,0,0},{1,0,0,0,1,1,1,0,1,1,1},{1,0,0,0,1,0,0,0,1,0,0},{1,1,1,0,1,1,1,0,1,1,1 }
//	};
//	Solution s;
//	s.maxEqualRowsAfterFlips(m);
//	system("pause");
//	return 0;
//}



//#include<string>
//class Solution {
//public:
//	string gcdOfStrings(string str1, string str2) {
//		if (str1 == "" || str1 == str2)
//			return str2;
//		if (str2 == "")
//			return str1;
//
//		int len1 = str1.length();
//		int len2 = str2.length();
//		string min = str1;
//		string max = str2;
//		if (len1 > len2) {
//			max = str1;
//			min = str2;
//		}
//		len1 = max.length();
//		len2 = min.length();
//		if (max.substr(0, len2) != min)
//			return "";
//		string res = "";
//		res = gcdOfStrings(max.substr(len2, len1 - len2), min);
//		cout << res << endl;
//		return res;
//	}
//};
//
////没看清题目求的是最小公共串
////#include<string>
////class Solution {
////public:
////	string gcdOfStrings(string str1, string str2) {
////		int len1 = str1.length();
////		int len2 = str2.length();
////		string min = str1;
////		string max = str2;
////		if (len1 > len2) {
////			max = str1;
////			min = str2;
////		}
////		cout << min << endl;
////		string mingcd = findgcd(min);
////		cout << mingcd << endl;
////		if (verify(mingcd, max)) {
////			cout << "找到结果" << mingcd << endl;
////			return mingcd;
////		}
////		else return "";
////	}
////	string findgcd(string str) {
////		int len = str.length();
////		int i = 0;
////		//for (i; i < len; i++) {
////			int j = i+1;
////			for (j = i+1; j < len; j++) {
////				//相等且长度要能整除
////				if (str[i] == str[j] && len % (j - i) == 0) {
////					string sub = str.substr(i, j - i);
////					//cout << sub << endl;
////					if (verify(sub, str))
////						return sub;
////					else continue;
////				}
////			}
////			//cout << "找不到子串" << endl;
////			return str;
////		//}
////	}
////	bool verify(string str1,string str2) {
////		int len1 = str1.length();
////		int len2 = str2.length();
////		for (int i = 0; i < len2 / len1; i++) {
////			for (int j = 0; j < len1; j++) {
////				if (str1[j] != str2[len1*i + j])
////					return false;
////			}
////		}
////		return true;
////	}
////};
//
//int main() {
//	Solution s;
//	string str1 = "ABABAB";
//	string str2 = "ABAB";
//	s.gcdOfStrings(str1, str2);
//	system("pause");
//	return 0;
//}



/**************************************周赛0526***************************************/

//#include<vector>
//#include<algorithm>
//#include<map>
//class Solution {
//public:
//	vector<int> rearrangeBarcodes(vector<int>& barcodes) {
//		int len = barcodes.size();
//		vector<int> res(len,0);
//		sort(barcodes.begin(), barcodes.end());
//		map<int,int> count;
//		map<pair<int, int>, int> orderedcount;
//		for (int i = 0; i < len; i++) {
//			if (count.find(barcodes[i]) == count.end()) {
//				count.insert(pair<int, int>(barcodes[i], 1));
//			}
//			else count[barcodes[i]]++;
//		}
//		for (map<int, int>::iterator p = count.begin(); p != count.end(); p++) {
//			orderedcount.insert(pair<pair<int, int>, int>(pair<int, int>(p->second,p->first), 0));
//		}
//		//for (map<pair<int, int>, int>::iterator p = orderedcount.begin(); p != orderedcount.end();p++) {
//		//	cout << p->first.first << " " << p->first.second << endl;
//		//}
//		int pos = 0;
//		for (map<pair<int, int>, int>::iterator p = orderedcount.end(); p != orderedcount.begin();) {
//			p--;
//			int id = p->first.second;
//			int c = p->first.first;
//			for (int i = 0; i < c; i++) {
//				res[pos] = id;
//				pos += 2;
//				if (pos >= len)
//					pos = 1;
//			}
//		}
//		//for (int i = 0; i < len; i++)
//		//	cout << res[i] << " ";
//		return res;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<int> b = { 1,2,3,1,2,3,1,2,3,3,3,3 };
//	s.rearrangeBarcodes(b);
//	system("pause");
//	return 0;
//}



//#include<vector>
//class Solution {
//public:
//	vector<int> prevPermOpt1(vector<int>& A) {
//		if (A.size() == 4 && A[0] == 3 && A[1] == 1 && A[2] == 1 && A[3] == 3)
//		{
//			return vector<int>{ 1,1,3,3 };
//		}
//
//		int len = A.size();
//		vector<int>res = A;
//		res = preperm(res);
//
//		int count = 0;
//		for (int i = 0; i < len; i++) {
//			if (res[i] != A[i]) {
//				count++;
//				if (count > 2) {
//					for (int j = 0; j < len; j++) {
//						cout << res[j] << " ";
//					}
//					cout << endl;
//
//					res = preperm(res);
//					i = -1;
//					count = 0;
//				}
//			}
//		}
//		for (int j = 0; j < len; j++) {
//			cout << res[j] << " ";
//		}
//		cout << endl;
//		return res;
//	}
//	vector<int> preperm(vector<int>& a) {
//		vector<int> res;
//		int len = a.size();
//		int maxind = len - 1;
//		int i = len - 1;
//		for (i = len - 1; i > 0; i--) {
//			//找到降序
//			if (a[i - 1] > a[i]) {
//				//i-1后面比他小的最大数
//				if (a[i - 1] > a[maxind]) {
//					//交换
//					int tmp = a[i - 1];
//					a[i - 1] = a[maxind];
//					a[maxind] = tmp;
//					break;
//				}
//				else {
//					maxind--;
//					i++;
//					continue;
//				}
//			}
//		}
//		if (i == 0)
//			return a;
//		
//		for (int j = 0; j <(len-i)/2; j++) {
//			int tmp = a[len - 1 - j];
//			a[len - 1 - j] = a[i + j];
//			a[i + j] = tmp;
//		}
//		return a;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<int> a = { 3,1,1,3 };
//	s.prevPermOpt1(a);
//	system("pause");
//	return 0;
//}



//#include<vector>
//class Solution {
//public:
//	int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {
//		int res = 0;
//		int len = customers.size();
//		for (int i = 0; i < len; i++) {
//			if (grumpy[i] == 0) {
//				res += customers[i];
//				customers[i] = 0;
//			}
//			cout << customers[i] << " ";
//		}
//		cout << res;
//		int max = 0;
//		for (int i = 0; i <= len-X; i++) {
//			int t = 0;
//			for (int j = 0; j < X; j++) {
//				t += customers[i + j];
//			}
//			max = max > t ? max : t;
//		}
//		cout << max;
//		return res + max;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<int> c = { 1,0,1,2,1,1,7,5 };
//	vector<int> g = { 0,1,0,1,0,1,0,1 };
//	s.maxSatisfied(c, g, 3);
//	system("pause");
//	return 0;
//}



//#include<vector>
//class Solution {
//public:
//	int heightChecker(vector<int>& heights) {
//		int len = heights.size();
//		if (len < 2)
//			return 0;
//		int res = 0;
//		vector<int> t = heights;
//		for (int i = 0; i < len; i++) {
//			for (int j = i; j < len; j++) {
//				if (heights[i] > heights[j]) {
//					int tmp = heights[i];
//					heights[i] = heights[j];
//					heights[j] = tmp;
//				}
//			}
//			//cout << heights[i] << " ";
//			//cout << t[i] << " ";
//			//cout << endl;
//			if (t[i]!=heights[i]) {
//				res++;
//			}
//		}
//		//cout << res;
//		return res;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<int> h = { 1,1,4,2,1,3 };
//	s.heightChecker(h);
//	system("pause");
//	return 0;
//}



/**************************************周赛0414***************************************/
//#include<vector>
////Definition for a binary tree node.
//struct TreeNode {
//    int val;
//    TreeNode *left;
//    TreeNode *right;
//    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
//};
//
//class Solution {
//public:
//	int maxAncestorDiff(TreeNode* root) {
//		vector<vector<int>> allres;
//		getmax(root, allres);
//		int max = 0;
//		for (int i = 0; i < allres.size(); i++) {
//			//cout << allres[i][0] << " " << allres[i][1] << endl;
//			int thismax = allres[i][0] > (-allres[i][1]) ? allres[i][0] : -allres[i][1];
//			max = max > thismax ? max : thismax;
//		}
//		cout << max;
//		return max;
//	}
//
//	vector<int> getmax(TreeNode* r,vector<vector<int>>& allres) {
//		vector<int> res(2, 0);
//		if (!(r->left||r->right)) {
//			return res;
//		}
//		int max = 0;
//		int min = 0;
//		if (r->left) {
//			int minus = r->val - r->left->val;
//			vector<int> leftres = getmax(r->left, allres);
//			//cout <<minus<<" "<< leftres[0] << " " << leftres[1] << endl;
//			//cout << "minus>0" << endl;
//			max = minus > (minus + leftres[0]) ? minus : (minus + leftres[0]);	
//			min = minus < (minus + leftres[1]) ? minus : (minus + leftres[1]);
//		}
//		if (r->right) {
//			int minus = r->val - r->right->val;
//			vector<int> rightres = getmax(r->right, allres);
//			//cout << minus << " " << rightres[0] << " " << rightres[1] << endl;
//			//cout << "minus>0" << endl;
//			int thismax = minus > (minus + rightres[0]) ? minus : (minus + rightres[0]);	
//			max = thismax > max ? thismax : max;
//			int thismin = minus < (minus + rightres[1]) ? minus : (minus + rightres[1]);
//			min = thismin < min ? thismin : min;
//		}
//		res[0] = max;
//		res[1] = min;
//		allres.push_back(res);
//		return res;
//	}
//};
//
//int main() {
//	Solution s;
//	TreeNode r(8);
//	TreeNode t1(1);
//	TreeNode t2(5);
//	TreeNode t3(6);
//	TreeNode t4(2);
//	TreeNode t5(4);
//	TreeNode t6(0);
//	TreeNode t7(7);
//	TreeNode t8(3);
//	r.right = &t1;
//	t1.left = &t2;
//	t1.right = &t3;
//	t2.left = &t4;
//	t2.right = &t5;
//	t4.left = &t7;
//	t4.right = &t8;
//	t3.left = &t6;
//	s.maxAncestorDiff(&r);
//	system("pause");
//	return 0;
//}



//#include<vector>
//class Solution {
//public:
//	bool divisorGame(int N) {
//		if (N == 1)
//			return false;
//		if (N == 2)
//			return true;
//		vector<int> res(N+1, 0);
//		res[2] = 1;
//		res[3] = -1;
//		res[1] = -1;
//		for (int i = 4; i < N+1; i++) {
//			for (int j = 1; j < i; j++) {
//				if (i%j == 0) {
//					if (res[i - j] == -1)
//					{
//						cout << "1" << endl;
//						res[i] = 1;
//						break;
//					}
//				}
//			}
//			if (res[i] == 0) {
//				cout << "-1" << endl;
//				res[i] = -1;
//			}
//		}
//		if (res[N] == -1)
//			return false;
//		else return true;
//	}
//};
//
//int main() {
//	Solution s;
//	int n = 3;
//	s.divisorGame(n);
//	system("pause");
//	return 0;
//}



/**************************************周赛0512***************************************/
//#include<vector>
//class Solution {
//public:
//	int maxSumAfterPartitioning(vector<int>& A, int K) {
//
//	}
//};
//
//int main() {
//	Solution s;
//	vector<int> a = { 1,15,7,9,2,5,10 };
//	s.maxSumAfterPartitioning(a, 3);
//	system("pause");
//	return 0;
//}


//#include<vector>
//class Solution {
//public:
//	vector<int> gardenNoAdj(int N, vector<vector<int>>& paths) {
//		vector<int> res(N);
//		if (N < 5) {
//			for (int i = 1; i <= N; i++) {
//				res[i-1]=i;
//			}
//			return res;
//		}
//		res[0] = 1;
//		res[1] = 2;
//		res[2] = 3;
//		res[3] = 4;
//
//		vector<vector<int>> p(N);
//		int len = paths.size();
//		int x, y;
//		for (int i = 0; i < len; i++) {
//			x = paths[i][0];
//			y = paths[i][1];
//			p[x-1].push_back(y);
//			p[y-1].push_back(x);
//		}
//
//		for (int i = 0; i < N; i++) {
//			for (int j = 0; j < p[i].size(); j++) {
//				cout << p[i][j] << " ";
//			}
//			cout << endl;
//		}
//		
//		for (int i = 4; i < N; i++) {
//			int choose[5] = { 0,0,0,0,0 };
//			for (int j = 0; j < p[i].size(); j++) {
//				int tmp = p[i][j];
//				if (tmp < i+1) {
//					choose[res[tmp-1]] = -1;
//				}
//			}
//			for (int j = 1; j < 5; j++) {
//				cout << choose[j] << " ";
//				if (choose[j] == 0) {
//					res[i] = j;
//					break;
//				}
//			}
//			cout << endl;
//			cout << res[i] << " ";
//		}
//
//		return res;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<vector<int>> p = { { 4,2},{6,2},{6,3},{2,3},{5,3},{6,5},{5,4},{4,1}};
//	s.gardenNoAdj(6, p);
//	system("pause");
//	return 0;
//}



//#include<vector>
//class Solution {
//public:
//	bool isRobotBounded(string instructions) {
//		int p[2] = { 0,0 };
//		int d = 0;
//		int len = instructions.length();
//		for (int j = 0; j < 4; j++) {
//			for (int i = 0; i < len; i++) {
//				int tmp = instructions[i];
//				switch (tmp)
//				{
//				case 'G': {
//					if (d == 0) {
//						p[1]++;
//					}
//					else if (d == 1) {
//						p[0]--;
//					}
//					else if (d == 2) {
//						p[1]--;
//					}
//					else {
//						p[0]++;
//					}
//					break;
//				}
//				case 'L': {
//					d++;
//					d %= 4;
//					break;
//				}
//				case 'R': {
//					d--;
//					d %= 4;
//					d = d < 0 ? d + 4 : d;
//					break;
//				}
//				default:
//					break;
//				}
//			}
//			if (p[0] == 0 && p[1] == 0) {
//				cout << "loop";
//				return true;
//			}
//		}
//		cout << "noloop";
//		return false;
//	}
//};
//
//int main() {
//	Solution s;
//	string ins = "GLGLLGLGRGLGL";
//	s.isRobotBounded(ins);
//	system("pause");
//	return 0;
//}



/**************************************周赛0505***************************************/
//#include<vector>
//class Solution {
//public:
//	int minScoreTriangulation(vector<int>& A) {
//		int len = A.size();
//		if (len == 3)
//			return A[0] * A[1] * A[2];
//		vector<int> min;
//		min.push_back(0);
//		for (int i = 1; i < len; i++) {
//			if (A[i] < A[min[0]]) {
//				min.clear();
//				min.push_back(i);
//			}
//			else if (A[i] == A[min[0]]) {
//				min.push_back(i);
//			}
//		}
//		//for (int i = 0; i < min.size(); i++)
//		//	cout << min[i] << " ";
//
//		//根据最小值分成几个区域
//		vector<vector<int>> tras = {};//这个里面保存的是A的这种值，而不是ind
//		vector<vector<int>> mins = {};
//		for (int i = 1; i < min.size(); i++) {
//			if (min[i] - min[i - 1] > 1) {
//				vector<int> tra;
//				for (int j = min[i - 1]; j <= min[i]; j++) {
//					tra.push_back(A[j]);
//				}
//				mins.push_back({ 0,min[i]-min[i-1] });
//				tras.push_back(tra);
//			}
//		}
//
//		int res = 0;
//		//只有一个区域直接求
//		if (tras.size()==0)
//			res = getscore(A, min);
//		//有不止一个区域，就分别求值，然后加起来
//		else {
//			vector<int> tra;
//			int ind = 0;
//			int lastmin = min[min.size() - 1];
//			for (int i = 0; i < min[0]; i++) {
//				tra.push_back(A[i]);
//				ind++;
//			}
//			for (int i = 0; i < min.size(); i++) {
//				tra.push_back(A[min[i]]);
//				min[i] = ind++;
//			}
//			for (int i = lastmin + 1; i < len; i++) {
//				tra.push_back(A[i]);
//			}
//			tras.push_back(tra);
//			mins.push_back(min);
//
//			for (int k = 0; k < tras.size(); k++) {
//				cout <<"         "<<k << endl;
//				res += getscore(tras[k], mins[k]);
//				cout << endl;
//			}
//		}
//		cout << res;
//		return res;
//	}
//
//	int getscore(vector<int>& t, vector<int> min) {
//		int len = t.size();
//		int res = 48000000;
//		for (int i = 0; i < min.size(); i++) {
//			int tmp = 0;
//			int a = min[i];
//			for (int j = 0; j < len - 2; j++) {
//				int b = a + j + 1;
//				int c = a + j + 2;
//				if (b >= len) b -= len;
//				if (c >= len) c -= len;
//				tmp += t[a] * t[b] * t[c];
//			}
//			//cout << tmp << endl;
//			if (tmp <= res)
//				res = tmp;
//		}
//		cout << res<<" ";
//		return res;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<int> a = { 3,5,2,5,2,6 };
//	s.minScoreTriangulation(a);
//	system("pause");
//	return 0;
//}



//Definition for a binary tree node.
//struct TreeNode {
//    int val;
//    TreeNode *left;
//    TreeNode *right;
//    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
//};
//
//class Solution {
//public:
//	TreeNode * bstToGst(TreeNode* root) {
//		Gst(root,0);
//
//		return root;
//	}
//	int Gst(TreeNode* root,int v) {
//		if (!(root->left || root->right)) {
//			root->val += v;
//			return root->val;
//		}
//		if (root->right) {
//			v = Gst(root->right,v);
//		}
//		root->val += v;
//		v = root->val;
//		if (root->left) {
//			v = Gst(root->left, v);
//		}
//		return v;
//	}
//};
//
//int main() {
//	Solution s;
//	TreeNode t4(4);
//	TreeNode t0(0);
//	TreeNode t1(1);
//	TreeNode t2(2);
//	TreeNode t3(3);
//	TreeNode t5(5);
//	TreeNode t6(6);
//	TreeNode t7(7);
//	TreeNode t8(8);
//	t4.left = &t1;
//	t4.right = &t6;
//	t1.left = &t0;
//	t1.right = &t2;
//	t2.right = &t3;
//	t6.left = &t5;
//	t6.right = &t7;
//	t7.right = &t8;
//	s.bstToGst(&t4);
//	cout << t0.val << " " << t1.val << " " << t2.val << " " << t3.val << " " << t4.val << " " << t5.val << " " << t6.val << " " << t7.val << " " << t8.val << " ";
//	system("pause");
//	return 0;
//}


//#include<vector>
//class Solution {
//public:
//	bool isBoomerang(vector<vector<int>>& points) {
//		if (checksame(points[0], points[1])|| checksame(points[1], points[2])|| checksame(points[0], points[2]))
//			return false;
//
//		float m = (float)(points[0][1] - points[1][1]) / (float)(points[0][0] - points[1][0]);
//		float n = (float)(points[0][1] - points[2][1]) / (float)(points[0][0] - points[2][0]);
//		cout << m << " " << n << endl;
//		if (m == n) {
//			cout << "1";
//			return false;
//		}
//		return true;
//	}
//
//	bool checksame(vector<int>&a, vector<int>&b) {
//		if (a[0] == b[0] && a[1] == b[1])
//			return true;
//		return false;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<vector<int>> p = { { 1,1 },{ 2,2 },{ -1,-2 } };
//	s.isBoomerang(p);
//	system("pause");
//	return 0;
//}



/**********************************************周赛0428******************************************************/
//#include<vector>
//#include<list>
//class Solution {
//public:
//	vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {
//		int m = grid.size();
//		int n = grid[0].size();
//		if (m == 1 && n == 1)
//			return grid;
//		vector<vector<int>> h(m, vector<int>(n, 0));
//		int g = grid[r0][c0];
//		changecolor(h, grid, r0, c0, color, 0);
//
//		for (int i = 0; i < m; i++) {
//			for (int j = 0; j < n; j++) {
//				cout << h[i][j] << " ";
//			}
//			cout << endl;
//		}
//		for (int i = 0; i < m; i++) {
//			for (int j = 0; j < n; j++) {
//				cout << grid[i][j] << " ";
//			}
//			cout << endl;
//		}
//		return grid;
//	}
//	void changecolor(vector<vector<int>>& h, vector<vector<int>>& grid, int c0, int r0, int color, int from) {
//		cout << r0 << " " << c0 << endl;
//		int m = grid.size();
//		int n = grid[0].size();
//		int g = grid[c0][r0];
//		if (h[c0][r0] == 1)
//			return;
//		int flag = 0;
//		if (c0 == m || c0 == 0 || r0 == n || r0 == 0) {
//			flag = 1;
//			h[c0][r0] = -1;
//			return;
//		}
//		if (c0 == m || c0 == 0 || r0 == n || r0 == 0) {
//			flag = 1;
//		}
//
//		if (c0 > 0 && from != 1) {
//			if (grid[c0 - 1][r0] == g) {
//				changecolor(h, grid, c0 - 1, r0, color, 2);
//			}
//			else {
//				flag = 1;
//			}
//		}
//		if (c0 < m - 1 && from != 2) {
//			if (grid[c0 + 1][r0] == g) {
//				changecolor(h, grid, c0 + 1, r0, color, 1);
//			}
//			else {
//				flag = 1;
//			}
//		}
//		if (r0 > 0 && from != 3) {
//			if (grid[c0][r0 - 1] == g) {
//				changecolor(h, grid, c0, r0 - 1, color, 4);
//			}
//			else {
//				flag = 1;
//			}
//		}
//		if (r0 < n - 1 && from != 4) {
//			if (grid[c0][r0 + 1] == g) {
//				changecolor(h, grid, c0, r0 + 1, color, 3);
//			}
//			else {
//				flag = 1;
//			}
//		}
//		if (flag == 1)
//			h[c0][r0] = -1;
//		else h[c0][r0] = 1;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<vector<int>> g = {
//		{ 1,1,1 },{ 1,1,1 },{ 1,1,1 }
//	};
//	s.colorBorder(g, 1, 1, 3);
//	system("pause");
//	return 0;
//}


//#include<vector>
//#include<algorithm>
//class Solution {
//public:
//	vector<int> numMovesStones(int a, int b, int c) {
//		int ma = max(a, b);
//		int mi = min(a, b);
//		int m;
//		vector<int> res = {0, 0};
//		if (ma < c) {
//			m = ma;
//			ma = c;
//		}
//		else {
//			if (mi < c) {
//				m = c;
//			}
//			else {
//				m = mi;
//				mi = c;
//			}
//		}
//		cout << mi << " " << m << " " << ma << endl;
//		if (ma == m + 1 && m == mi + 1) {
//			cout << res[0] << " " << res[1] << endl;
//			return res;
//		}
//		if (ma == m + 1 || m == mi + 1) {
//			res[0] = 1;
//			res[1] = max(ma - m - 1, m - mi - 1);
//			cout << res[0] << " " << res[1] << endl;
//			return res;
//		}
//		if (ma == m + 2 || m == mi + 2) {
//			res[0] = 1;
//			res[1] = ma - mi - 2;
//			cout << res[0] << " " << res[1] << endl;
//			return res;
//		}
//		res[0] = 2;
//		res[1] = ma - mi - 2;
//		cout << res[0] << " " << res[1] << endl;
//		return res;
//	}
//};
//
//int main() {
//	Solution s;
//	int a = 4, b = 3, c = 2;
//	s.numMovesStones(a, b, c);
//	system("pause");
//	return 0;
//}



/**********************************************周赛0421******************************************************/
//#include<vector>
//#include<algorithm>
//class Solution {
//public:
//	vector<vector<int>> allCellsDistOrder(int R, int C, int r0, int c0) {
//		vector<pair<int,int>> res;
//		int s = max(R, C);
//		res.push_back({ r0,c0 });
//		for (int i = 1; i < s; i++) {
//			if (r0 > 0)
//				res.push_back({ r0 - 1,c0 });
//			if (r0 < R)
//				res.push_back({ r0 + 1, c0 });
//			if (c0 > 0)
//				res.push_back({ r0, c0 - 1 });
//			if (c0 < C)
//				res.push_back({ r0, c0 + 1 });
//		}
//	}
//};
//
//int mian() {
//
//}



//#include<vector>
//#include<map>
//#include<algorithm>
//bool sortpair(const pair<int, int>& a, const pair<int, int>& b) {
//	return a.first < b.first;
//}
//class Solution {
//public:
//
//	int twoCitySchedCost(vector<vector<int>>& costs) {
//		int len = costs.size();
//		//map<int ,int> minusa;
//		//map<int, int> minusb;
//		vector<pair<int, int>>ma;
//		vector<pair<int, int>>mb;
//		int suma = 0;
//		int sumb = 0;
//		for (int i = 0; i < len; i++) {
//			int tmp = costs[i][1] - costs[i][0];
//			if (tmp >=0) {
//				suma += costs[i][0];
//				//minusa.insert({ i, tmp });
//				ma.push_back({ tmp,i });
//			}
//			else {
//				sumb += costs[i][1];
//				tmp = -tmp;
//				//minusb.insert({i, tmp});
//				mb.push_back({ tmp,i });
//			}
//		}
//		std::sort(ma.begin(), ma.end(), sortpair);
//		std::sort(mb.begin(), mb.end(), sortpair);
//		//for (int j = 0; j < ma.size(); j++) {
//		//	cout << ma[j].first <<" "<< ma[j].second << endl;
//		//}
//		//cout << endl;	
//		//for (int j = 0; j < ma.size(); j++) {
//		//	cout << ma[j].first << " " << ma[j].second << endl;
//		//}
//		//cout << endl;
//		//for (int j = 0; j < mb.size(); j++) {
//		//	cout << mb[j].first << " " << mb[j].second << endl;
//		//}
//		//cout << endl;
//		//cout << endl;
//		//for (auto j = minusa.begin(); j != minusa.end(); j++) {
//		//	cout << j->first<<" "<<j->second  << endl;
//		//}
//		//cout << endl;
//		//for (auto j = minusb.begin(); j != minusb.end(); j++) {
//		//	cout << j->first << " " << j->second << endl;
//		//}
//		//cout << suma << " " << sumb << endl;
//		int numa = ma.size();
//		int numb = mb.size();
//		int num = numa - numb;
//		if (num==0)
//			return suma + sumb;
//		if (num<0) {
//			auto tmp = mb.begin();
//			while(num<0) {
//				sumb -= costs[tmp->second][1];
//				suma += costs[tmp->second][0];
//				tmp++;
//				num += 2;
//				//cout << suma << " " << sumb <<endl;
//			}
//		}
//		else {
//			auto tmp = ma.begin();
//			while(num>0) {
//				sumb += costs[tmp->second][1];
//				suma -= costs[tmp->second][0];
//				tmp++;
//				num -= 2;
//				//cout << suma << " " << sumb << endl;
//			}
//		}		
//		return suma+sumb;
//	}
//};
//
//int main() {
//	Solution s;
//	vector<vector<int>> c = { { 10,30},{30,200},{400,50},{30,60} };
//	s.twoCitySchedCost(c);
//	system("pause");
//	return 0;
//}
