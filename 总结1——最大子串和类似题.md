# 总结1——最大子串和类似题

### 题目

> 第五十三题：最大子序和
>
> 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> ```
> Input: [-2,1,-3,4,-1,2,1,-5,4],
> Output: 6
> Explanation: [4,-1,2,1] has the largest sum = 6.
> ```

> 第三题：无重复字符的最长子串
>
> 给定一个字符串，找出不含有重复字符的最长子串的长度。
>
> ```
> 输入: "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> 
> 输入: "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> 
> 输入: "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> ```

> 

### 思路

* 53：要求的是最大的和。最大和计算之前，旧的最大和是一定为零的。因此，一遍循环，当前最大值每次加上当前值，最大值每次和当前最大进行比较，然后检查当前最大是否<0，是就进行清零，这样能保证下一个当前最大一定是大于现在的当前最大。

- 3：利用一个map数据结构，来标记每一个字符上一次出现的位置，初始化时全部置为0。遍历字符串：对每一个字符，如果对应map值不为0，说明之前出现过该字符，就先把最大长度与当前长度（当前位减去左指针的位）进行比较并取较大值，再把代表左指针的标记和该字符上一次出现的位置进行比较，并取靠右的；最后把每一个字符对应的map值记为当前位。循环进行到最后一轮时，比较最大长度和最后一段无重复段的长度并取最大值。思路类似于一个左指针和一个右指针，左指针指向上一个不重复的值，右指针不断右移直到结束。

### 源码

* 53

  ```c++
  class Solution {
  public:
      int maxSubArray(vector<int>& nums) {
  		int res = nums[0];
  		int len = nums.size();
  		int tmp = 0;
  		for (int i = 0; i < len; i++) {
  			tmp += nums[i];
  			res = max(res, tmp);
  			tmp = max(0, tmp);			
  			//cout << res << tmp << endl;
  		}
  		cout << res;
  		return res;
      }
  };
  ```

* 3：

  ```c++
  class Solution {
  public:
      int lengthOfLongestSubstring(string s) {
  		int length = 0;
  		map<char,int> pos;
  		//初始化pos
  		char tmp;
  		for (int i = 0; i < s.length(); i++) {
  			tmp = s[i];
  			pos[tmp] = 0;
  		}
  		//距离最近的上一个重复位(类似左指针）
  		int lasti = 0;
  		for (int i = 0; i < s.length(); i++) {
  			//遇到有重复
  			if (pos[s[i]] != 0) {
  				length = (length > (i-lasti)) ? length : (i - lasti);
  				lasti = (lasti > (pos[s[i]])) ? lasti : (pos[s[i]]);
  			}
  			//结束后处理最后一个不重复的情况!!!!!!!!!!!!!!!!!!这里很关键
  			if (i == (s.length() - 1)) {
  				length = (length > (s.length() - lasti)) ? length : (s.length() - lasti);
  			}
  			pos[s[i]] = i + 1;
  		}
  		return length;
      }
  };
  
  ```

- 

  ```c++
  
  ```