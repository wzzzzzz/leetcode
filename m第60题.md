# 第六十题——第 *k* 个排列

### 题目

> 给出集合 `[1,2,3,…,*n*]`，其所有元素共有 *n*! 种排列。
>
> 按大小顺序列出所有排列情况，并一一标记，当 *n* = 3 时, 所有排列如下：
>
> 1. `"123"`
> 2. `"132"`
> 3. `"213"`
> 4. `"231"`
> 5. `"312"`
> 6. `"321"`
>
> 给定 *n* 和 *k*，返回第 *k* 个排列。
>
> **说明：**
>
> - 给定 *n* 的范围是 [1, 9]。
> - 给定 *k* 的范围是[1,  *n*!]。

### 举例

```
输入: n = 3, k = 3
输出: "213"

输入: n = 4, k = 9
输出: "2314"
```

### 思路

* 思路：参考字典序全排列思路。字典序全排列的序号计算，根据中介数计算序号。相反的，根据序号也可以计算中介数，然后根据中介数来计算原数。问题的难点在于根据中介数计算原数，不能只靠一遍循环，因为一遍循环的话tmp后面变化了前面的数大小关系可能会变，但是又不能重复计算大小关系，因此用一个compared数组来记录有没有比较过大小关系，每次只比较没被比较过的，一旦tmp变化（也就是小于或等于tmp），就把compared标记为1，然后从头计算。

### 复杂度

- O(n^2)


### 源码

* 思路

  ```c++
  class Solution {
  public:
      string getPermutation(int n, int k) {
  		k--;
  		//阶乘数
  		int factorial[8] = { 1,2,6,24,120,720,5040,40320};
  		//中介数
  		int num[9] = { 0,-1,-1,-1,-1,-1,-1,-1,-1 };
  		string res;
  		//计算中介数
  		for (int i = n-2; i >=0; i--) {
  			num[i+1] = k / factorial[i];
  			k = k % factorial[i];
  		}
  
  		for (int i = n-1; i >=0; i--) {
  			int compared[9] = { -1,-1,-1,-1,-1,-1,-1,-1,-1 };
  			if (num[i] != -1) {
  				int tmp = num[i] + 1;
  				for (int j = 0; j < n - i - 1; j++) {
  					if (tmp >= (int)res[j] - '0'&&compared[j]==-1) {
  						tmp++;
  						compared[j] = 1;
  						j = -1;
  					}
  				}
  				res += to_string(tmp);
  			}
  		}
  
  		//cout << res;
  		return res;     
      }
  };
  ```

