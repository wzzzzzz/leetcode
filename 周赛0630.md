# 第1103题——分糖果

### 题目

> 排排坐，分糖果。
>
> 我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。
>
> 给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。
>
> 然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。
>
> 重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。
>
> 返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。
>
> **提示：**
>
> 1. `1 <= candies <= 10^9`
> 2. `1 <= num_people <= 1000`

### 举例

```
输入：candies = 7, num_people = 4 输出：[1,2,3,1] 解释： 第一次，ans[0] += 1，数组变为 [1,0,0,0]。 第二次，ans[1] += 2，数组变为 [1,2,0,0]。 第三次，ans[2] += 3，数组变为 [1,2,3,0]。 第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。

输入：candies = 10, num_people = 3 输出：[5,2,3] 解释： 第一次，ans[0] += 1，数组变为 [1,0,0]。 第二次，ans[1] += 2，数组变为 [1,2,0]。 第三次，ans[2] += 3，数组变为 [1,2,3]。 第四次，ans[0] += 4，最终数组变为 [5,2,3]。
```

### 思路

* 思路：遍历每次candies减去相应数量，直到candies<0结束。

### 复杂度

- O（n）


### 源码

```c++
class Solution {
public:
    vector<int> distributeCandies(int candies, int num_people) {
		vector<int> res(num_people, 0);
		int ind = 0;
		int num = 1;
		while (candies > 0) {
			if (ind >= num_people) {
				ind = 0;
			}
			if (candies < num)
				res[ind] += candies;
			else res[ind] += num;
			candies -= num;

			num++;
			ind++;
		}

		return res;        
    }
};
```

# 第1104题——二叉树寻路

### 题目

> 在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。
>
> 如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；
>
> 而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。
>
> ![1562640816816](C:\Users\LWZ\AppData\Roaming\Typora\typora-user-images\1562640816816.png)
>
> 给你树上某一个节点的标号 `label`，请你返回从根节点到该标号为 `label` 节点的路径，该路径是由途经的节点标号所组成的。
>
> **提示：**
>
> 1. `1 <= label <= 10^6`

### 举例

```
输入：label = 14
输出：[1,3,4,14]

输入：label = 26
输出：[1,2,6,10,26]
```

### 思路

- 思路：既然是无限二叉树，那就是满的，因此假设不走s形那么计算父节点就很容易，/2即可。现在是s形，所以每隔一次，对算得的父节点位置进行对称，但是要注意下一次计算还要用不对称的值。

### 复杂度

- 1000*n

### 源码

```c++
class Solution {
public:
    vector<int> pathInZigZagTree(int label) {
 		int la = label;
		int d = 1;
		int dmax = 1;
		while (la>1) {
			la /= 2;
			d++;
			dmax *= 2;
		}
		dmax = dmax * 2 - 1;

		vector<int> res(d);
		res[d - 1] = label;
		for (int i = d - 1; i > 0; i--) {
			int next = label / 2;
			dmax /= 2;
			if ((d-i) % 2 == 0) {

				res[i - 1] = next;
			}
			else {
				//计算对称的标签
				int next1 = dmax - (next - (dmax + 1) / 2);

				res[i - 1] = next1;
			}
			label = next;			
		}

		return res;       
    }
};
```

# 第1105题——

### 题目

> （这是一个 **交互式问题** ）
>
> 给你一个 **山脉数组** `mountainArr`，请你返回能够使得 `mountainArr.get(index)` **等于** `target` **最小** 的下标 `index` 值。
>
> 如果不存在这样的下标 `index`，就请返回 `-1`。
>
> 所谓山脉数组，即数组 `A` 假如是一个山脉数组的话，需要满足如下条件：
>
> **首先**，`A.length >= 3`
>
> **其次**，在 `0 < i < A.length - 1` 条件下，存在 `i` 使得：
>
> - `A[0] < A[1] < ... A[i-1] < A[i]`
> - `A[i] > A[i+1] > ... > A[A.length - 1]`
>
> 你将 **不能直接访问该山脉数组**，必须通过 `MountainArray` 接口来获取数据：
>
> - `MountainArray.get(k)` - 会返回数组中索引为`k` 的元素（下标从 0 开始）
> - `MountainArray.length()` - 会返回该数组的长度
>
> **注意：**
>
> 对 `MountainArray.get` 发起超过 `100` 次调用的提交将被视为错误答案。
>
> **提示：**
>
> 1. `3 <= mountain_arr.length() <= 10000`
> 2. `0 <= target <= 10^9`
> 3. `0 <= mountain_arr.get(index) <= 10^9`

### 举例

```
输入：array = [1,2,3,4,5,3,1], target = 3 输出：2 解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。

输入：array = [0,1,2,4,2,1], target = 3
输出：-1
解释：3 在数组中没有出现，返回 -1。
```

### 思路

- 思路：首先二分法找到山峰（每次循环要调用两次get函数，比较mid和mid+1的值来判断是上坡还是下坡），然后在山峰的两侧二分法分别查找目标（每次循环要调用一次get函数）。

### 复杂度

- 2*log(n)+log(k)+log(n-k)

### 源码

```c++

```

# 第1106题——

### 题目

> 如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。
>
> 花括号展开的表达式可以看作一个由 花括号、逗号 和 小写英文字母 组成的字符串，定义下面几条语法规则：
>
> - 如果只给出单一的元素 x，那么表达式表示的字符串就只有 "x"。 
>   - 例如，表达式 {a} 表示字符串 "a"。
>   - 而表达式 {ab} 就表示字符串 "ab"。
> - 当两个或多个表达式并列，以逗号分隔时，我们取这些表达式中元素的并集。
>   - 例如，表达式 {a,b,c} 表示字符串 "a","b","c"。
>   - 而表达式 {a,b},{b,c} 也可以表示字符串 "a","b","c"。
> - 要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。
>   - 例如，表达式 {a,b}{c,d} 表示字符串 "ac","ad","bc","bd"。
> - 表达式之间允许嵌套，单一元素与表达式的连接也是允许的。
>   - 例如，表达式 a{b,c,d} 表示字符串 "ab","ac","ad"。
>   - 例如，表达式 {a{b,c}}{{d,e}f{g,h}} 可以代换为 {ab,ac}{dfg,dfh,efg,efh}，表示字符串 "abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"。
>
> 给出表示基于给定语法规则的表达式 expression，返回它所表示的所有字符串组成的有序列表。
>
> **提示：**
>
> 1. 1 <= expression.length <= 50
> 2. expression[i] 由 '{'，'}'，',' 或小写英文字母组成
> 3. 给出的表达式 expression 用以表示一组基于题目描述中语法构造的字符串

### 举例

```
输入："{a,b}{c{d,e}}"
输出：["acd","ace","bcd","bce"]

输入："{{a,z}, a{b,c}, {ab,z}}"
输出：["a","ab","ac","z"]
解释：输出中 不应 出现重复的组合结果。
```

### 思路

- 思路：参考四则运算的计算，把符号和数字分别放在两个栈里。本题中逗号等同于+，笛卡尔积等同于*，{ }等同于()。注意算完后要排序，去重。

### 复杂度

- O(n)???

### 源码

```c++

```

