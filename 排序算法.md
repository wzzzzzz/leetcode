# 排序算法

### 题目

> 给定一个字符串 **s**，找到 **s** 中最长的回文子串。你可以假设 **s** 的最大长度为1000。

### 思路

* 冒泡排序：两重循环，每次比较相邻的两个并调整位置，每次循环能排对一个最大的，n次循环就全排对了。O(n^2)
* 鸡尾酒排序（冒泡排序改进）：两重循环，每次循环前半段和冒泡一样，排对一个最大的元素，后半段逆向进行，排对一个最小的元素。O(n^2)
* 选择排序：两重循环，每次循环找到最大的（或最小的）然后和最前头的交换（而不是依次交换）。O(n^2)
* 插入排序（像扑克牌整理牌）：一重循环，每次从未排序的里取一个，在已排序的里找到合适位置，并插入（插入时需要把后面的依次位移）。O(n^2)
* 二分插入排序（插入排序改进）：每次查找插入位置时使用二分法来查找。O(n^2)
* 希尔排序：？？？
* 归并排序：两两排序—>四四排序—>八八排序直到全部。每次用两个指针来比较，小的加进结果。O(nlogn)
* 快速排序：首先选择一个基准元素（常选第一个或最后一个）。然后通过一趟排序将数据分成两部分，左边比基准小的，右边是比基准大的，遍历时，两个指针，左边指针遇到大的就和右边交换，直到两个指针相遇。此时基准的位置已经排好。然后分别对两边进行同样的步骤。O(nlogn)
* 堆排序：首先建堆，然后在其基础上排序，使左子树都小于父节点小于右子树
* 基数排序：首先要知道最大数是多少。然后以不同的基数为“桶”，把待排序的数字放在不同的桶中，然后分别对每个桶里的数字排序（简单的排序方法都可以），最后依次合并起来。O(n)

### 源码

* 基础思路

  ```c++
  
  ```


