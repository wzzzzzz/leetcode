# 排序算法

### 题目

> 给定一个字符串 **s**，找到 **s** 中最长的回文子串。你可以假设 **s** 的最大长度为1000。

### 思路

* 冒泡排序：两重循环，每次比较相邻的两个并调整位置，每次循环能排对一个最大的，n次循环就全排对了。O(n^2)
* 鸡尾酒排序（冒泡排序改进）：两重循环，每次循环前半段和冒泡一样，排对一个最大的元素，后半段逆向进行，排对一个最小的元素。O(n^2)
* 选择排序：两重循环，每次循环找到最大的（或最小的）然后和最前头的交换（而不是依次交换）。O(n^2)
* 插入排序（像扑克牌整理牌）：一重循环，每次从未排序的里取一个，在已排序的里找到合适位置，并插入（插入时需要把后面的依次位移）。O(n^2)
* 二分插入排序（插入排序改进）：每次查找插入位置时使用二分法来查找。O(n^2)
* 希尔排序：？？？
* 归并排序：两两排序—>四四排序—>八八排序直到全部。每次用两个指针来比较，小的加进结果。O(nlogn)
* 快速排序：首先选择一个基准元素（常选第一个或最后一个）。然后通过一趟排序将数据分成两部分，左边比基准小的，右边是比基准大的，遍历时，两个指针，左边指针遇到大的就和右边交换，直到两个指针相遇。此时基准的位置已经排好。然后分别对两边进行同样的步骤。O(nlogn)
* 堆排序：首先建堆，然后在其基础上排序，使左子树都小于父节点小于右子树
* 基数排序：首先要知道最大数是多少。然后以不同的基数为“桶”，把待排序的数字放在不同的桶中，然后分别对每个桶里的数字排序（简单的排序方法都可以），最后依次合并起来。O(n)

### 源码

* 基础思路

  ```c++
  class Solution {
  public:
      string longestPalindrome(string s) {
          string res = "";
  		for (int i = 0; i < s.length() - res.length(); i++) {
  			for (int j = s.length(); j > (i+res.size()); j--) {
  				//判断s(i,j)是否回文
  				int k;
  				for (k = 0; k < ((j - i) / 2); k++) {	
  					if (s[i + k] != s[j - k - 1])
  						break;
  				}
  				if (k == (j - i) / 2) {
  					//cout << res.c_str() << " " << s.substr(i, j - i).c_str() << endl;
  					if(res.length()<(j-i))
  						res = s.substr(i, j - i);
  				}
  			}
  		}
  		//cout << res.c_str() << endl;
  		return res;
      }
  };
  ```

* solution1：

  ```c++
  //超出时间限制所以没过！！！???????????????????????????????
  
  class Solution {
  public:
      string longestPalindrome(string s) {
  		string res = "";
  		//倒序字符串
  		string s0 = s;
  		int len = s.length();
  		for (int i = 0; i < len; i++) {
  			s0[len - i-1] = s[i];
  		}
  		//cout << s0.c_str() << endl;
  		for (int i = 0; i < len-res.length(); i++) {
  			for (int j = i+1; j < len; j++) {
  				string tmp = s0.substr(i, j - i+1);
  				if (s.find(tmp) != s.npos) {
  					string tmprev = tmp;
  					int tmplen = tmp.length();
  					for (int k = 0; k < tmplen; k++) {
  						tmprev[tmplen - k - 1] = tmp[k];
  					}
  					if (s.find(tmp) == s.find(tmprev)) {
  						//cout << tmp.c_str() << endl;
  						if (res.length() < tmp.length())
  							res = tmp;
  					}
  				}
  			}
  		}
  		if (res == "")
  			res = s[0];
  		return res;
      }
  };
  ```

### 疑问

		//会出现死循环？j不断减小
		string res="";
		for (int i = 0; i < s.length() - res.length(); i++) {
			for (int j = s.length()-1; j >= (i+res.length()); j--) {...}}
			
		//会出现i=0时不做内循环？？？
		string res="";
		for (int i = 0; i < s.length() - res.length(); i++) {
			for (int j = s.length()-1; j > (i+res.size()-1); j--) {...}}
		
	    //这样就没问题？？？
		for (int i = 0; i < s.length() - res.length(); i++) {
			cout << res.size() << " " << endl;
			for (int j = s.length()-1; j > (i+res.size()); j--) {...}}