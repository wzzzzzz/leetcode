# 第九十五题——不同的二叉搜索树2

### 题目

> 给定一个整数 *n*，生成所有由 1 ... *n* 为节点所组成的**二叉搜索树**。

### 举例

```
输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

### 思路

* 思路：试着写一下就能看出规律。n=3时，分别有以1、2、3为root的三种，以1位root的全部只有右子树，右子树与n=2类似，同理以3位root的也是如此，而以2位root的左子树和右子树都与n=1类似。因为规律为，R(1)=R(n-1) *R(0)，R(2)=R(n-2) *R(1)，R(3)=R(n-3) *R(2)。并且以1为root和以3为root结果是类似的，因此总体来说子树的个数是对称的。以此类推。因此，用一个数组来记录结果，n=0,1,2结果已知，然后用一个循环，从3算到n，每次先计算前半部分子树和，然后乘2，然后如果n是奇数再加上中间一位的子树个数。

### 复杂度

- ？？？


### 源码

* 思路

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
   * };
   */
  class Solution {
  public:
      vector<TreeNode*> generateTrees(int n) {
  		vector<TreeNode*> res;
  		if (n == 0) {
  			return res;
  		}
  		if (n == 1) {
  			TreeNode tmp(1);
  			res.push_back(&tmp);
  			return res;
  		}
  		if (n == 2) {
  			TreeNode tmp1(1);
  			TreeNode tmp2(2);
  			tmp1.right = &tmp2;
  			res.push_back(&tmp1);
  			TreeNode tmp21(1);
  			TreeNode tmp22(2);
  			tmp22.left = &tmp21;
  			res.push_back(&tmp22);
  			return res;
  		}
  		res = generateTree(1, n);
  
  		return res;
  	}
  
  	vector<TreeNode*> generateTree(int start, int end) {
  		vector<TreeNode*> res;
  		if (start == end) {
  			TreeNode* tmp = new TreeNode(start);
  			res.push_back(tmp);
  		}
  		else if (start == end-1) {
  			TreeNode* tmp11 = new TreeNode(start);
  			TreeNode* tmp12 = new TreeNode(end);
  			tmp11->right = tmp12;
  			res.push_back(tmp11);
  			TreeNode* tmp21 = new TreeNode(start);
  			TreeNode* tmp22 = new TreeNode(end);
  			tmp22->left = tmp21;
  			res.push_back(tmp22);
  		}
  		else {
  			for (int i = start; i <= end; i++) {
  				if (i == start) {
  					vector<TreeNode*> allright =generateTree(start+1,end);
  					int rightlen = allright.size();
  					for (int j = 0; j < rightlen; j++) {
  						TreeNode* tmp = new TreeNode(i);
  						tmp->right = allright[j];
  						res.push_back(tmp);
  					}
  				}
  				else if (i == start + 1) {
  					TreeNode* tmpleft=new TreeNode(start);
  					vector<TreeNode*> allright =generateTree(start+2,end);
  					int rightlen = allright.size();
  					for (int j = 0; j < rightlen; j++) {
  						TreeNode* tmp = new TreeNode(i);
  						tmp->left = tmpleft;
  						tmp->right = allright[j];
  						res.push_back(tmp);
  					}
  				}
  				else if (i == end - 1) {
  					TreeNode* tmpright=new TreeNode(end);
  					vector<TreeNode*> allleft = generateTree(start,end-2);
  					int leftlen = allleft.size();
  					for (int j = 0; j < leftlen; j++) {
  						TreeNode* tmp = new TreeNode(i);
  						tmp->right = tmpright;
  						tmp->left = allleft[j];
  						res.push_back(tmp);
  					}
  				}
  				else if (i == end) {
  					vector<TreeNode*> allleft = generateTree(start,end-1);
  					int leftlen = allleft.size();
  					for (int j = 0; j < leftlen; j++) {
  						TreeNode* tmp = new TreeNode(i);
  						tmp->left = allleft[j];
  						res.push_back(tmp);
  					}
  				}
  				else {
  					vector<TreeNode*> allleft = generateTree(start,i - 1);
  					int leftlen = allleft.size();
  					vector<TreeNode*> allright = generateTree(i + 1, end);
  					int rightlen = allright.size();
  					for (int j = 0; j < leftlen; j++) {
  						for (int k = 0; k < rightlen; k++) {
  							TreeNode* tmp = new TreeNode(i);
  							tmp->left = allleft[j];
  							tmp->right = allright[k];
  							res.push_back(tmp);
  						}
  					}
  				}
  			}
  		}
  		//for (int i = 0; i < res.size(); i++)
  		//{
  		//	while (res[i]) {
  		//		cout << (*res[i]).val << " ";
  		//		res[i] = (res[i])->right;
  		//	}
  		//	cout << endl;
  		//}
  		//cout << endl;
  		return res;
  	}
  };
  ```


