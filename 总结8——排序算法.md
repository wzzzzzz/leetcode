# 总结8——排序算法

### 题目

> 

### 思路

* 冒泡排序：两重循环，每次比较相邻的两个并调整位置，每次循环能排对一个最大的，n次循环就全排对了。O(n^n)
* 鸡尾酒排序（冒泡排序改进）：两重循环，每次循环前半段和冒泡一样，排对一个最大的元素，后半段逆向进行，排对一个最小的元素。O(n^(n/2)
* 选择排序：两重循环，每次循环找到最大的（或最小的）然后和最前头的交换（而不是依次交换）。O(n^n)
* 插入排序（像扑克牌整理牌）：一重循环，每次从未排序的里取一个，在已排序的里找到合适位置，并插入（插入时需要把后面的依次位移）。O(n^n)
* 二分插入排序（插入排序改进）：每次查找插入位置时使用二分法来查找。O(n^?)
* 希尔排序：在有一组希尔值（步长序列）（比如{1,2,4……}）的基础上，补偿从大向小取，记为k，每次把数组分割成k组（不是连续分而是间隔分），每一组有n/k个，对每一组分别进行排序，然后把k组连起来。当步长到达1时，就到达了排序的结尾。希尔排序的底层排序方法推荐用插入排序。比较优秀的一组希尔值是取两两互素的。
* 归并排序：两两排序—>四四排序—>八八排序直到全部。每次用两个指针来比较，小的加进结果。O(nlogn)
* 快速排序：首先选择一个基准元素（常选第一个或最后一个）。然后通过一趟排序将数据分成两部分，左边比基准小的，右边是比基准大的，遍历时，两个指针，左边指针遇到大的就和右边交换，直到两个指针相遇。此时基准的位置已经排好。然后分别对两边进行同样的步骤。O(nlogn)
* 堆排序：首先建堆，然后在其基础上排序，使左子树都小于父节点小于右子树
* 基数排序：首先要知道最大数是多少。然后以不同的基数为“桶”，把待排序的数字放在不同的桶中，然后分别对每个桶里的数字排序（简单的排序方法都可以），最后依次合并起来。O(n)

### 源码

* 基础思路

  ```c++
  
  ```


